<link rel="import" href="../polymer/polymer.html">

<!--
This element allows you to lazy load images as you scroll

Example:

    <fs-lazyload src='path/to/image.png' delay='200'></fs-lazyload>

@group Seed Elements
@element fs-lazyload
@demo demo/index.html

-->
<dom-module id="fs-lazyload">

  <template>
    <content></content>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'fs-lazyload',

    extends: 'img',

    properties: {
      /**
       * The path to the image.
       */
       src: String,

       /**
       * The amount of milliseconds to wait
       * before checking if the image is in the viewport
       * to load it.
       */
       delay: {
        type: Number,
        value: 300
       }

    },

    // Element Lifecycle

    created: function() {

      // Create an empty image
      fallbackImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAEElEQVR42gEFAPr/AP///wAI/AL+Sr4t6gAAAABJRU5ErkJggg==";

      

      // swap original src attribute
      this.original = this.src;
      this.src = fallbackImage;

      

    },

    attached: function() {
      // `attached` fires once the element and its parents have been inserted
      // into a document.
      //
      // This is a good place to perform any work related to your element's
      // visual state or active behavior (measuring sizes, beginning animations,
      // loading resources, etc).

      var _this = this;


      var rect   = this.getBoundingClientRect();
      var top    = document.documentElement.scrollTop
      var bottom = document.documentElement.clientHeight

      // If the image is in the viewport
      if ((rect.bottom > top && rect.bottom < bottom) ||
           (rect.top > top && rect.bottom < bottom) ||
           (rect.top > top && rect.top < bottom )) {

        this.addEventListener('load', this.onLoad);
        this.addEventListener('error', this.onError);
        this.src = this.original;

      } else {
        window.addEventListener('scroll', function() {_this.throttle()});
      }
    },

    detached: function() {
      // The analog to `attached`, `detached` fires when the element has been
      // removed from a document.
      //
      // Use this to clean up anything you did in `attached`.
      console.log('detached');
      this.removeEventListener('load', this.onLoad);
      this.removeEventListener('error', this.onError);
      window.removeEventListener('scroll', this.throttle);
    },

    // Element Behavior

    onLoad: function (e) {
        window.removeEventListener('scroll', this.throttle());
        console.log('caller', e.target);
      },

    inspect: function(e) {
        var rect   = this.getBoundingClientRect();
        var top    = document.documentElement.scrollTop;
        var bottom = document.documentElement.clientHeight;
        // If the image is in the viewport
        if ((rect.bottom > top && rect.bottom < bottom) ||
               (rect.top > top && rect.bottom < bottom) ||
               (rect.top > top && rect.top < bottom )) {

          this.addEventListener('load', this.onLoad);
          this.addEventListener('error', this.onError);
          this.src = this.original;
        }
      },

    /**
     * Check for the bounds and load the image
     *
     */
    throttle: function() {
        var now = Date.now();
        if (!this.previous) {
          this.previous = now;
        }
        var remaining = this.delay - (now - this.previous);
        if (remaining <= 0) {
          this.previous = now;
          this.inspect();
        }
    }

  });

</script>
